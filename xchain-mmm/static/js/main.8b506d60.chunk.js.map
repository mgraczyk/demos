{"version":3,"sources":["urlState.js","Sends.js","Sequences.js","App.js","index.js"],"names":["_STATE_PARAM_KEY","sleep","ms","Promise","r","setTimeout","withEagerLatestRace","f","cb","limitMs","ctr","tLast","a","myCtr","tWait","performance","now","result","args","putStateInUrl","state","urlParams","URLSearchParams","window","location","search","encoded","btoa","JSON","stringify","encodeState","set","history","replaceState","pathname","loadStateFromUrl","encodedState","parse","atob","error","console","decodeState","get","SendsList","sends","length","map","send","id","valueIn","Sends","sendsFromA","sendsFromB","Sequences","sequences","errorMessage","body","className","slice","sequence","readOnly","style","width","height","value","orderingToSequence","sequenceId","ordering","A","B","K","stateA","balance","remoteBalance","stateB","bridgeTxns","statePairs","transfers","evt","fromA","isStart","isOnA","localState","push","currency","amount","amountReceived","amountSent","transfersById","transfer","join","_defaultState","reconciled","initialA","initialB","sendsFromAInput","sendsFromBInput","orderingsInput","orderingsError","_keysToStoreInUrl","tryParseOrdering","orderingInput","letters","replace","countA","countB","stackA","stackB","letter","pop","isEnd","App","props","handleChange","e","setState","target","name","reconcile","getVals","csv","label","split","filter","v","Number","i","fromB","orderings","results","tryParseOrderings","o","reset","_","createUrlStateWriteWithDebounce","unbouncedReconcile","urlState","this","prevProps","prevState","snapshot","Object","fromEntries","k","onClick","htmlFor","type","autoComplete","onChange","placeholder","title","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"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","file":"static/js/main.8b506d60.chunk.js","sourcesContent":["const _STATE_PARAM_KEY = '__rus';\n\nconst sleep = (ms) => new Promise((r) => setTimeout(r, ms));\n\n// Wraps a function and forwards results to a callback.\n// Drops pending calls when a new call comes in,\n// but always eventually returns the latest result.\n//\n//         \\       \\   \\  \\\n// wrapped -\\-------\\---\\--\\------------\n//           \\       \\   \\  ~~~~~   <<< Wait a bit (predict cancel)\n//            \\       \\   \\      \\\n// await f ----???-----??x-?x-----???---\n//                \\                  \\\n//      cb -----------------------------\nconst withEagerLatestRace = (f, cb, limitMs = 300) => {\n  let ctr = 0;\n  let tLast = 0;\n  return async (...args) => {\n    const myCtr = ctr += 1;\n    const tWait = tLast + limitMs - performance.now();\n    if (tWait > 0) {\n      await sleep(tWait);\n    }\n\n    if (ctr !== myCtr) {\n      return;\n    }\n\n    tLast = performance.now();\n    let result = null;\n    if (f) {\n      result = await f(...args);\n    }\n    if (ctr === myCtr && cb) {\n      cb(result, args);\n    }\n  };\n};\n\n// TODO: Fix for non-ascii.\nfunction encodeState(state) {\n  return window.btoa(JSON.stringify(state));\n}\n\nfunction decodeState(encodedState) {\n  if (!encodedState) {\n    return null;\n  }\n\n  try {\n    return JSON.parse(window.atob(encodedState));\n  } catch (error) {\n    console.error(error);\n    return null;\n  }\n}\n\nfunction putStateInUrl(state) {\n  const urlParams = new URLSearchParams(window.location.search);\n  const encoded = encodeState(state);\n  urlParams.set(_STATE_PARAM_KEY, encoded);\n  window.history.replaceState(null, null, `${window.location.pathname}?${urlParams}`);\n}\n\nfunction loadStateFromUrl() {\n  const urlParams = new URLSearchParams(window.location.search);\n  return decodeState(urlParams.get(_STATE_PARAM_KEY)) || {};\n}\n\nfunction createUrlStateWriteWithDebounce(timeoutMs = 500) {\n  return withEagerLatestRace(\n    null,\n    (_, args) => putStateInUrl(args[0]),\n    timeoutMs,\n  );\n}\n\nexport {\n  putStateInUrl,\n  loadStateFromUrl,\n  withEagerLatestRace,\n  createUrlStateWriteWithDebounce,\n};\n","function SendsList({sends}) {\n  return (\n    <ul>\n      {sends.length === 0 && <span>No Sends</span>}\n      {sends.map(send => (\n        <li key={send.id}>\n          <span>id={send.id}, value={send.valueIn ?? \"??\"}</span>\n        </li>\n      ))}\n    </ul>\n  );\n}\n\nfunction Sends({sendsFromA, sendsFromB}) {\n  return (\n    <div>\n      <h3>Transfers</h3>\n      <h4>From A to B</h4>\n      <SendsList sends={sendsFromA} />\n\n      <h4>From B to A</h4>\n      <SendsList sends={sendsFromB} />\n    </div>\n  );\n}\n\n\nexport default Sends;\n","\nfunction Sequences({sequences, errorMessage}) {\n  const body = errorMessage ? \n    <span className=\"curve-error\">{errorMessage}</span>\n    :\n    <div>\n      {sequences.length === 0 && <span>No Sequences</span>}\n      {sequences.slice(0,1000).map(sequence => (\n        <div key={sequence.id}>\n          <textarea readOnly style={{width: \"100%\", height: \"450px\"}}\n                    value={JSON.stringify(sequence, \"\\n\", \"  \")} />\n        </div>\n      ))}\n    </div>;\n\n  return (\n    <div>\n      <h3>Sequences</h3>\n      {body}\n    </div>\n  );\n}\n\nfunction listAllSequencesRecursive(sendsToStart, sendsToEnd, prefix, sequencesOut) {\n  if (sendsToStart.length === 0 && sendsToEnd.length === 0) {\n    if (prefix.length) {\n      sequencesOut.push(prefix);\n    }\n    return;\n  }\n  \n  for (let i = 0; i < sendsToStart.length; ++i) {\n    const newSendsToStart = [\n      ...sendsToStart.slice(0, i),\n      ...sendsToStart.slice(i + 1)\n    ];\n    const send = sendsToStart[i];\n    const newSendsToEnd = [...sendsToEnd, send];\n    const newPrefix = [\n      ...prefix,\n      { ...send, isStart: true },\n    ];\n    listAllSequencesRecursive(newSendsToStart, newSendsToEnd, newPrefix, sequencesOut);\n  }\n  for (let i = 0; i < sendsToEnd.length; ++i) {\n    const send = sendsToEnd[i];\n    const newSendsToEnd = [\n      ...sendsToEnd.slice(0, i),\n      ...sendsToEnd.slice(i + 1)\n    ];\n    const newPrefix = [\n      ...prefix,\n      { ...send, isEnd: true },\n    ];\n    listAllSequencesRecursive(sendsToStart, newSendsToEnd, newPrefix, sequencesOut);\n  }\n}\n\nfunction orderingToSequence(sequenceId, ordering, A, B, K) {\n  const stateA = {\n    balance: A,\n    remoteBalance: B,\n    K,\n  };\n  const stateB = {\n    balance: B,\n    remoteBalance: A,\n    K,\n  };\n\n  const bridgeTxns = {};\n  const statePairs = [{stateA: {...stateA}, stateB: {...stateB}}];\n  const transfers = [];\n\n  for (const evt of ordering) {\n    const {id, valueIn, fromA, isStart} = evt;\n    const isOnA = (isStart && fromA) || (!isStart && !fromA);\n    const localState = isOnA ? stateA : stateB;\n    if (isStart) {\n      transfers.push({id, currency: isOnA ? \"A\" : \"B\", amount: -valueIn});\n      const amountReceived = valueIn;\n      localState.balance += amountReceived;\n\n      const amountSent = localState.remoteBalance - K / localState.balance;\n\n      // TODO: Give extra when remote doesn't match??\n      // But then maybe remote will think my balance is higher than it actually is?\n\n      localState.remoteBalance -= amountSent;\n      bridgeTxns[id] = { amountReceived, amountSent };\n    } else {\n      const { amountSent, amountReceived } = bridgeTxns[id];\n      localState.remoteBalance += amountReceived;\n      localState.balance -= amountSent;\n      transfers.push({id, currency: isOnA ? \"A\" : \"B\", amount: amountSent});\n    }\n    statePairs.push({stateA: {...stateA}, stateB: {...stateB}});\n  }\n\n  const transfersById = {};\n  for (const transfer of transfers) {\n    const {id, currency, amount} = transfer;\n    transfersById[id] = transfersById[id] ?? {};\n    transfersById[id][currency] = (transfersById[id][currency] ?? 0) + amount;\n  }\n\n  const orderingToLetter = ({fromA, isStart}) => {\n    if (fromA) {\n      if (isStart) return \"A\";\n      return \"a\";\n    } else {\n      if (isStart) return \"B\";\n      return \"b\";\n    }\n  }\n\n  return {\n    ordering: ordering.map(orderingToLetter).join(\"\"),\n    stateA,\n    stateB,\n    transfersById,\n    bridgeTxns,\n    statePairs,\n    id: sequenceId,\n  };\n}\n\nfunction getAllSequences(sends, A, B, K) {\n  const sequencesOut = [];\n  listAllSequencesRecursive(sends, [], [], sequencesOut, 0, 5);\n  return sequencesOut.map((ordering, i) => orderingToSequence(i, ordering, A, B, K));\n}\n\n\nexport {Sequences, getAllSequences, orderingToSequence};\n","import \"./App.css\";\nimport React from 'react';\nimport {\n  loadStateFromUrl,\n  withEagerLatestRace,\n  createUrlStateWriteWithDebounce,\n} from \"./urlState.js\";\nimport Sends from \"./Sends.js\";\nimport { Sequences, orderingToSequence } from \"./Sequences.js\";\n\n\nconst _defaultState = {\n  reconciled: false,\n  initialA: \"500\",\n  initialB: \"550\",\n  sendsFromAInput: \"20,50\",\n  sendsFromBInput: \"50,100\",\n  orderingsInput: \"AABBaabb\\nAABBbbaa\\nAaAaBbBb\\nAAaaBBbb\",\n  orderingsError: null,\n  K: null,\n  sendsFromA: [],\n  sendsFromB: [],\n  sequences: [],\n};\n\nconst _keysToStoreInUrl = [\n  \"initialA\",\n  \"initialB\",\n  \"sendsFromAInput\",\n  \"sendsFromBInput\",\n  \"orderingsInput\",\n];\n\nconst tryParseOrdering = (orderingInput, sendsFromA, sendsFromB) => {\n  const regExp = /[^ABab]/g;\n  const letters = orderingInput.replace(regExp, '');\n  if (letters.length === 0) {\n    // Empty, so skip it.\n    return [null, null];\n  }\n\n  let countA = 0;\n  let countB = 0;\n\n  const stackA = [];\n  const stackB = [];\n  const ordering = [];\n\n  for (const letter of letters) {\n    if (letter === \"A\") {\n      if (countA >= sendsFromA.length) {\n        return [null, 'Too many \"A\" characters'];\n      }\n      const send = sendsFromA[countA];\n      stackA.push(send);\n      countA += 1;\n      ordering.push({ ...send, isStart: true });\n    } else if (letter === \"B\") {\n      if (countB >= sendsFromB.length) {\n        return [null, 'Too many \"B\" characters'];\n      }\n      const send = sendsFromB[countB];\n      stackB.push(send);\n      countB += 1;\n      ordering.push({ ...send, isStart: true });\n    } else if (letter === \"a\") {\n      if (stackA.length === 0) {\n        return [null, 'Too many \"a\" characters'];\n      }\n      const send = stackA.pop();\n      ordering.push({ ...send, isEnd: true });\n    } else if (letter === \"b\") {\n      if (stackB.length === 0) {\n        return [null, 'Too many \"b\" characters'];\n      }\n      const send = stackB.pop();\n      ordering.push({ ...send, isEnd: true });\n    }\n  }\n\n  if (stackA.length) {\n    return [null, 'Not enough \"a\" characters'];\n  }\n  if (stackB.length) {\n    return [null, 'Not enough \"b\" characters'];\n  }\n  if (countA !== sendsFromA.length) {\n    return [null, 'Not enough \"A\" characters'];\n  }\n  if (countB !== sendsFromB.length) {\n    return [null, 'Not enough \"B\" characters'];\n  }\n\n  return [ordering, null];\n};\n\nconst tryParseOrderings = (orderingsInput, sendsFromA, sendsFromB) => {\n  const orderings = orderingsInput.split(/\\r?\\n/);\n  const results = [];\n  for (let i = 0; i < orderings.length; ++i) {\n    const [result, error] = tryParseOrdering(orderings[i], sendsFromA, sendsFromB);\n    if (error) {\n      return [null, `Line ${i}: ${error}`];\n    }\n    if (result) {\n      results.push(result);\n    }\n  }\n  return [results, null];\n}\n\nclass App extends React.Component {\n  constructor(props) {\n    super(props);\n\n    this.putStateInUrl = createUrlStateWriteWithDebounce(1000);\n    this.unbouncedReconcile = withEagerLatestRace(this.reconcile, null, 500);\n  }\n\n  state = _defaultState;\n\n  componentDidMount() {\n    const urlState = loadStateFromUrl();\n    this.setState({\n      ...this.state,\n      ...urlState,\n    });\n  }\n\n  componentDidUpdate(prevProps, prevState, snapshot) {\n    if (this.state !== prevState) {\n      this.putStateInUrl(Object.fromEntries(_keysToStoreInUrl.map(k => [k, this.state[k]])));\n      this.unbouncedReconcile();\n    }\n  }\n\n  handleChange = e => {\n    this.setState({[e.target.name]: e.target.value, reconciled: false});\n  }\n\n  reconcile = () => {\n    const {state} = this;\n    if (state.reconciled) {\n      return;\n    }\n\n    const getVals = (csv, label) => \n      csv\n      .split(\",\")\n      .filter(v => v.length)\n      .map(v => Number(v));\n\n\n    const sendsFromA = getVals(state.sendsFromAInput)\n      .map((v, i) => ({\n        id: `A.${i}`,\n        fromA: true,\n        valueIn: v,\n      }));\n    const sendsFromB = getVals(state.sendsFromBInput)\n      .map((v, i) => ({\n        id: `B.${i}`,\n        fromB: true,\n        valueIn: v,\n      }));\n\n    const A = Number(state.initialA);\n    const B = Number(state.initialB);\n    const K = A * B;\n    const [orderings, orderingsError] = tryParseOrderings(state.orderingsInput, sendsFromA, sendsFromB);\n\n    let sequences;\n    if (!orderingsError) {\n      sequences = orderings.map((o, i) => orderingToSequence(i, o, A, B, K));\n    }\n\n    this.setState({\n      reconciled: true,\n      K, sendsFromA, sendsFromB,\n      sequences, orderingsError,\n    });\n  }\n\n  reset = () => {\n    this.setState(_defaultState, this.reconcile);\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n      <h2>Computation</h2>\n      <div className=\"curve-form\">\n        <span>&nbsp;</span>\n        <button onClick={this.reset} style={{\"width\": \"5em\"}}>Reset</button>\n\n        <label htmlFor=\"initialA\">Initial A:</label>\n        <input type=\"text\" name=\"initialA\" id=\"initialA\"\n               autoComplete=\"off\"\n               value={this.state.initialA} onChange={this.handleChange} />\n\n        <label htmlFor=\"initialB\">Initial B:</label>\n        <input type=\"text\" name=\"initialB\" id=\"initialB\"\n               autoComplete=\"off\"\n               value={this.state.initialB} onChange={this.handleChange} />\n\n        <label htmlFor=\"K\">K:</label>\n        <span id=\"K\">{this.state.K}</span>\n\n        <label htmlFor=\"sendsFromAInput\">Send Amounts From A (comma separated):</label>\n        <input type=\"text\" name=\"sendsFromAInput\" id=\"sendsFromAInput\"\n               autoComplete=\"off\"\n               placeholder=\"10,20,...\"\n               value={this.state.sendsFromAInput} onChange={this.handleChange} />\n\n        <label htmlFor=\"sendsFromBInput\">Send Amounts From B (comma separated):</label>\n        <input type=\"text\" name=\"sendsFromBInput\" id=\"sendsFromBInput\"\n               autoComplete=\"off\"\n               placeholder=\"10,50,...\"\n               value={this.state.sendsFromBInput} onChange={this.handleChange} />\n\n        <label htmlFor=\"orderingsInput\">Orderings.&nbsp;\n          <em>\"AaBb\" means start send from A, then end send from A, then start send from B, then end etc. \n           \"ABba\" means start send from A, then start send from B, then end send from b, then end from a.</em>\n        </label>\n        <textarea type=\"text\" name=\"orderingsInput\" id=\"orderingsInput\"\n               className={`${this.state.orderingsError ? \"curve-error\" : \"\"}`}\n               title={this.state.orderingsError}\n               autoComplete=\"off\"\n               placeholder=\"AAAaBbaa..\"\n               value={this.state.orderingsInput} onChange={this.handleChange} />\n      </div>\n\n      <hr />\n\n      {!this.state.reconciled ? <span>Computing...</span> :\n        <>\n        <Sends\n          sendsFromA={this.state.sendsFromA}\n          sendsFromB={this.state.sendsFromB} />\n        <Sequences\n          errorMessage={this.state.orderingsError}\n          sequences={this.state.sequences} />\n        </>\n      }\n      </div>\n    );\n  }\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './bootstrap-reboot.min.css';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n"],"sourceRoot":""}